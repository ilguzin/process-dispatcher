# process-dispatcher

[![Build Status](https://travis-ci.org/ilguzin/process-dispatcher.svg?branch=master)](https://travis-ci.org/ilguzin/process-dispatcher)
[![Coverage Status](https://coveralls.io/repos/github/ilguzin/process-dispatcher/badge.svg?branch=master)](https://coveralls.io/github/ilguzin/process-dispatcher?branch=master)

JavaScript process dispatcher backed by NodeJS Child Processes functionality. Intended to wrap any native NodeJS module to make it executable in subprocess. Interprocess messaging works via IPC

## The Intention

A single instance of NodeJS runs in a single thread. The whole idea standing behind the library is to take advantage of 
multi-core systems and give user a way to run an _existing code_ in a not only non-blocking way (which NodeJS certainly is)
but also engaging the whole power of a machine spreading the processing among processes (both execution and hardware).

### Isn't that what NodeJS [cluster](https://nodejs.org/api/cluster.html) module is all about?

Exactly. That's what it is about. The _process-dispatcher_ library in it turn is a rich wrapper around the _child_process_ giving
you the functionality which _[cluster](https://nodejs.org/api/cluster.html)_ claims to be implemented by end point 
developer. Among others are: easy to kick start with (all API are ready to use), master <-> worker IPC messaging.

Along side with the fact that the implementation is similar to the _[cluster](https://nodejs.org/api/cluster.html)_ module
the important thing is that the  _process-dispatcher_ original intent is not load balancing or a kind of, but making 
microservices out of modules. Another words you wrap any module with _process-dispatcher_ functionality to make it 
work as microservice isolated within its own space with all consequences. 

## Documentation

Latest [API Documentation](https://ilguzin.github.io/process-dispatcher/) is auto-generated by JSDoc.

